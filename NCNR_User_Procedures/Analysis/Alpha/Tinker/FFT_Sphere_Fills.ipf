#pragma rtGlobals=1		// Use modern global access method.// -- APRIL 2014 -- see the function:// Function FillSphereRadiusNoOverlap(mat,grid,rad,xc,yc,zc,fill)// and where it is called to get a handle on how to re-do the sphere filling calls// - string of pearls// - random walk of beads (restricted angles, or simply self-avoiding)// - others??////////// currently a bunch of commented out, old, untested macros that // could be modified to do some automated testing and verification// of the various combinations of the mtrix fills//// the calls to the actual calculation must be updated, plus lots of other stuff,// but it's a good start/////////////////Macro Do10()////	Variable t1,num,nx,rval,grid,rho,qmin,qmax,ii//	//	//	//grid=5//	//rval=0.62*grid//	rval=20//	grid=1.6*rval//	rho=1//	num=50		//number of qvals//	qmin=0.001//	qmax = 0.5//	Make/O/N=(num) ival1,ival2,ival3,ival4,ival5,ival6,ival7,ival8,ival9,ival10,qval//	qval = alog(log(qmin) + x*((log(qmax)-log(qmin))/num))//	//	ii=1//	do//		sparse=0//		SparseRodFill(sparse,10,10)//		nx=numpnts(x3d)//		t1=ticks//		//XOP is obsolete////		$("ival"+num2str(ii) ) = IQRfromXYZ_XOP(x3d,y3d,z3d,qval,rval,rho,grid,nx)////		$("ival"+num2str(ii) ) = CalcIQRfromXYZ(x3d,y3d,z3d,qval,rho,rval,grid)////		Printf "Igor time for %d qvals and %d spheres = %g seconds\r",num,nx,(ticks-t1)/60.15////		AppendtoGraph $("ival"+num2str(ii) ) vs qval//		Print "no calculation is done in Do10"//		Print "ii = ",ii//		ii+=1//	while(ii<11)//	Print "Completed OK"//End////Macro DoSpheres()//	////	Variable qmin=0.005,qmax=0.5//	Variable numq=100//	//	Make/O/N=(numq) ival_2x,ival_3x,ival_4x,ival_5x,ival_6x,ival_7x,ival_8x,qval_sph//	qval_sph = alog(log(qmin) + x*((log(qmax)-log(qmin))/numq))//	//2//	FillSphere(mat,2,21,21,21,1)//	Save/O/C/P=home mat as "mat_sphere2.ibw"//	fDoCalc(qval_sph,ival_2x,20/2)//////	//3//	FillSphere(mat,3,21,21,21,1)//	Save/O/C/P=home mat as "mat_sphere3.ibw"//	fDoCalc(qval_sph,ival_3x,20/3)////	//4//	FillSphere(mat,4,21,21,21,1)//	Save/O/C/P=home mat as "mat_sphere4.ibw"//	fDoCalc(qval_sph,ival_4x,20/4)////	//5//	FillSphere(mat,5,21,21,21,1)//	Save/O/C/P=home mat as "mat_sphere5.ibw"//	fDoCalc(qval_sph,ival_5x,20/5)//	//6//	FillSphere(mat,6,21,21,21,1)//	Save/O/C/P=home mat as "mat_sphere6.ibw"//	fDoCalc(qval_sph,ival_6x,20/6)//		//6//	FillSphere(mat,7,21,21,21,1)//	Save/O/C/P=home mat as "mat_sphere7.ibw"//	fDoCalc(qval_sph,ival_7x,20/7)//	//8//	FillSphere(mat,8,21,21,21,1)//	Save/O/C/P=home mat as "mat_sphere8.ibw"//	fDoCalc(qval_sph,ival_8x,20/8)//End////Macro Do10Spheres()////	Variable t1,num,nx,rval,grid,rho,qmin,qmax,ii//	//	rval=5//	grid=1.6*rval//	rho=1//	num=50		//number of qvals//	qmin=0.001//	qmax = 0.5//	Make/O/N=(num) ival1,ival2,ival3,ival4,ival5,ival6,ival7,ival8,ival9,ival10,qval//	qval = alog(log(qmin) + x*((log(qmax)-log(qmin))/num))//	//	ii=1//	mat=0//	do//		SparseRodFill(mat,10,100)//		nx=numpnts(x3d)//		t1=ticks//		AltiSpheres(qval,$("ival"+num2str(ii) ),x3d,y3d,z3d,rval,(rval*0.62))////		$("ival"+num2str(ii) ) = CalcIQRfromXYZ(x3d,y3d,z3d,qval,rho,rval,grid)//		Printf "XOP time for %d qvals and %d spheres = %g seconds\r",num,nx,(ticks-t1)/60.15////		AppendtoGraph $("ival"+num2str(ii) ) vs qval//		Print "ii = ",ii//		ii+=1//	while(ii<11)//	Print "Completed OK"//End////Macro SetupBeads()//	Variable num,qmin,qmax//	//	num=50//	qmin=0.001//	qmax=0.5//	Make/O/N=(num) ival11,ival12,ival13,ival14,ival15,ival16,ival17,ival8,ival9,ival10,qval//	qval = alog(log(qmin) + x*((log(qmax)-log(qmin))/num))//	//	Make/O/B/N=(21,21,1000) mat//	//End////////Macro DoBeads()////	Variable start=11,rad=4,ii//	//	//SetupBeads()//	mat=0//	//	ii=1//	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1//	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1//	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1//		//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1	//	AddSphere(mat,rad,11,11,(start+2*rad*ii))//	ParseMatrix3D(mat)//	Save/T/O/P=home x3d,y3d,z3d as "beadXYZ"+num2str(ii)+".awav"//	ii+=1////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ii+=1////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ii+=1////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ii+=1////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ii+=1////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ii+=1////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ii+=1////	////	//8////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ParseMatrix3D(mat)////	fDoCalc($("ival"+num2str(ii)),20,rad)////	ii+=1////	////	//9////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ParseMatrix3D(mat)////	fDoCalc($("ival"+num2str(ii)),20,rad)////	ii+=1////	//10////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ParseMatrix3D(mat)////	fDoCalc($("ival"+num2str(ii)),20,rad)////	ii+=1////	//11////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ParseMatrix3D(mat)////	fDoCalc($("ival"+num2str(ii)),20,rad)////	ii+=1////	//12////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ParseMatrix3D(mat)////	fDoCalc($("ival"+num2str(ii)),20,rad)////	ii+=1////	//13////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ParseMatrix3D(mat)////	fDoCalc($("ival"+num2str(ii)),20,rad)////	ii+=1////	//14////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ParseMatrix3D(mat)////	fDoCalc($("ival"+num2str(ii)),20,rad)////	ii+=1////	//15////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ParseMatrix3D(mat)////	fDoCalc($("ival"+num2str(ii)),20,rad)////	ii+=1////	//16////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ParseMatrix3D(mat)////	fDoCalc($("ival"+num2str(ii)),20,rad)////	ii+=1////	//17////	AddSphere(mat,rad,11,11,(start+2*rad*ii))////	ParseMatrix3D(mat)////	fDoCalc($("ival"+num2str(ii)),20,rad)////	ii+=1////	//End