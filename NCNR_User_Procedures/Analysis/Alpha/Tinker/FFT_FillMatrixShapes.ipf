#pragma rtGlobals=1		// Use modern global access method.// Routines to fill a matrix with spheres in a desired pattern or method// - visualization of the 3-d object...// also contains routines to convert matrix to XYZ values for export to the calculations//// random point fills are also here, either random or Sobol////fills specified sphere//***Zeros the rest of the matrix iff yesZero==1//Function FillSphere(mat,rad,xc,yc,zc,yesZero)	WAVE mat	Variable rad,xc,yc,zc,yesZero		Variable ii,jj,kk,dik,numx,numy,numz		numx=DimSize(mat,0)	numy=DimSize(mat,1)	numz=DimSize(mat,2)	for(ii=0;ii<numx;ii+=1)		for(jj=0;jj<numy;jj+=1)			for(kk=0;kk<numz;kk+=1)				dik=sqrt( (ii-xc)^2+(jj-yc)^2+(kk-zc)^2 )				if(dik<=rad)					mat[ii][jj][kk] = 1				else					if(yesZero==1)						mat[ii][jj][kk] = 0					endif				endif			endfor		endfor	endfor		return(0)	End//grid is the size of each voxel in the matrix in angstroms (grid^3 is the volume)//radius is the real-space radius that you want the sphere to be//// fills sphere if fill=1, clears if fill=0Function FillSphereRadius(mat,grid,rad,xc,yc,zc,fill)	WAVE mat	Variable grid,rad,xc,yc,zc,fill		Variable ii,jj,kk,dik,numx,numy,numz,numVox	Variable x1,x2,y1,y2,z1,z2	numVox= rad/grid*3		//*3 for extra room, *2 is diam		numx=DimSize(mat,0)	numy=DimSize(mat,1)	numz=DimSize(mat,2)// keep the bounding box within bounds		x1 = (xc >= numVox) ? (xc-numVox) : 0	x2 = (xc + numVox) <= numx ? (xc + numVox) : numx	y1 = (yc >= numVox) ? (yc-numVox) : 0	y2 = (yc + numVox) <= numy ? (yc + numVox) : numy	z1 = (zc >= numVox) ? (zc-numVox) : 0	z2 = (zc + numVox) <= numz ? (zc + numVox) : numz//	print numvox//	Print x1,x2//	Print y1,y2//	print z1,z2	for(ii=x1;ii<x2;ii+=1)		for(jj=y1;jj<y2;jj+=1)			for(kk=z1;kk<z2;kk+=1)				dik=sqrt( (ii-xc)^2+(jj-yc)^2+(kk-zc)^2 )*grid				if(dik<=rad)					mat[ii][jj][kk] = fill//				else//					if(yesZero==1)//						mat[ii][jj][kk] = 0//					endif				endif			endfor		endfor	endfor		return(0)	End//grid is the size of each voxel in the matrix in angstroms (grid^3 is the volume)//radius is the real-space radius that you want the sphere to be//// fills sphere with fill value if the space is clear, that is there is nothing// there but solvent.//// actually runs 2x to make sure that there is no overlap//Function FillSphereRadiusNoOverlap(mat,grid,rad,xc,yc,zc,fill)	WAVE mat	Variable grid,rad,xc,yc,zc,fill		Variable ii,jj,kk,dik,numx,numy,numz,numVox	Variable x1,x2,y1,y2,z1,z2		NVAR FFT_SolventSLD = root:FFT_SolventSLD	numVox= rad/grid*3		//*3 for extra room, *2 is diam		numx=DimSize(mat,0)	numy=DimSize(mat,1)	numz=DimSize(mat,2)// keep the bounding box within bounds		x1 = (xc >= numVox) ? (xc-numVox) : 0	x2 = (xc + numVox) <= numx ? (xc + numVox) : numx	y1 = (yc >= numVox) ? (yc-numVox) : 0	y2 = (yc + numVox) <= numy ? (yc + numVox) : numy	z1 = (zc >= numVox) ? (zc-numVox) : 0	z2 = (zc + numVox) <= numz ? (zc + numVox) : numz	Variable err=0// check for an overlapping point in the sphere to fill	for(ii=x1;ii<x2;ii+=1)		for(jj=y1;jj<y2;jj+=1)			for(kk=z1;kk<z2;kk+=1)				dik=sqrt( (ii-xc)^2+(jj-yc)^2+(kk-zc)^2 )*grid				if( (dik<=rad) && (mat[ii][jj][kk] != FFT_SolventSLD) ) 		//if in sphere to fill AND already occupied					err += 1					return err		//get out now				endif			endfor		endfor	endfor		// OK, go ahead and fill	for(ii=x1;ii<x2;ii+=1)		for(jj=y1;jj<y2;jj+=1)			for(kk=z1;kk<z2;kk+=1)				dik=sqrt( (ii-xc)^2+(jj-yc)^2+(kk-zc)^2 )*grid				if(dik<=rad)					mat[ii][jj][kk] = fill				endif			endfor		endfor	endfor	return(0)	End// fills the sphere at the specified center and radius// the input matrix is Nx3 and will be extended by this routine// as needed to add the sphere//Function FillSphere3(mat3,rad,xc,yc,zc,yesZero)	WAVE mat3	Variable rad,xc,yc,zc,yesZero		Variable ii,jj,kk,dik,np		np = DimSize(mat3,0)	for(ii=xc-rad;ii<xc+rad;ii+=1)		for(jj=yc-rad;jj<yc+rad;jj+=1)			for(kk=zc-rad;kk<zc+rad;kk+=1)				dik=sqrt( (ii-xc)^2+(jj-yc)^2+(kk-zc)^2 )				if(dik<=rad)					InsertPoints/M=0 np, 1, mat3//					InsertPoints/M=1 np, 1, mat3//					InsertPoints/M=2 np, 1, mat3					mat3[np][0] = ii					mat3[np][1] = jj					mat3[np][2] = kk					np += 1				//one point has been added				else					if(yesZero==1)						//mat[ii][jj][kk] = 0					endif				endif			endfor		endfor	endfor		return(0)	End//erases specified sphere////obsolete//Function EraseSphere(mat,rad,xc,yc,zc)//	WAVE mat//	Variable rad,xc,yc,zc//	//	Variable ii,jj,kk,dik,numx,numy,numz//	//	numx=DimSize(mat,0)//	numy=DimSize(mat,1)//	numz=DimSize(mat,2)//	for(ii=0;ii<numx;ii+=1)//		for(jj=0;jj<numy;jj+=1)//			for(kk=0;kk<numz;kk+=1)//				dik=sqrt( (ii-xc)^2+(jj-yc)^2+(kk-zc)^2 )//				if(dik<=rad)//					mat[ii][jj][kk] = 0//				endif//			endfor//		endfor//	endfor//	//	return(0)	//End//erases specified sphere////obsolete//Function EraseSphereRadius(mat,grid,rad,xc,yc,zc)//	WAVE mat//	Variable grid,rad,xc,yc,zc//	//	Variable ii,jj,kk,dik,numx,numy,numz//	//	numx=DimSize(mat,0)//	numy=DimSize(mat,1)//	numz=DimSize(mat,2)//	for(ii=0;ii<numx;ii+=1)//		for(jj=0;jj<numy;jj+=1)//			for(kk=0;kk<numz;kk+=1)//				dik=sqrt( (ii-xc)^2+(jj-yc)^2+(kk-zc)^2 )*grid//				if(dik<=rad)//					mat[ii][jj][kk] = 0//				endif//			endfor//		endfor//	endfor//	//	return(0)	//End//fill = 1, erase = 0// // !! this does not check for overlap!!!Function  SphereAtEachPoint(mat,rad,pd)	Wave mat	Variable rad,pd		Wave x3d=x3d	Wave y3d=y3d	Wave z3d=z3d		Variable ii=0,num=numpnts(x3d),meanRad	meanRad=rad	NVAR  grid=root:FFT_T		for(ii=0;ii<num;ii+=1)		//print "sphere ",ii		//FillSphere(mat,rad,x3d[ii],y3d[ii],z3d[ii],0)		if(pd !=0 )			rad = meanRad + gnoise(pd*meanRad)		endif		FillSphereRadius(mat,grid,rad,x3d[ii],y3d[ii],z3d[ii],1)	endfor		End//fills cylinder (fill == 1) or erases it (fill == 0)//// xc,yc,zc is the center// grid is the grid spacing (A)// rad is the desired radius// len is the desired length, in the z-directionFunction FillZCylinder(mat,grid,rad,xc,yc,zc,len,fill)	WAVE mat	Variable grid,rad,xc,yc,zc,len,fill		Variable ii,pts	//put half the length above - half below	pts = trunc(len/2/grid)	for(ii=(zc-pts);ii<(zc+pts);ii+=1)		FillXYCircle(mat,grid,rad,xc,yc,ii,fill)	endfor		return(0)	End//fills the specified circle (fill==1), or erases it (fill == 0)//zloc assumed to be a valid z-index of the matrixFunction FillXYCircle(mat,grid,rad,xc,yc,zloc,fill)	WAVE mat	Variable grid,rad,xc,yc,zloc,fill		Variable ii,jj,dik,numx,numy,numz		numx=DimSize(mat,0)	numy=DimSize(mat,1)	for(ii=0;ii<numx;ii+=1)		for(jj=0;jj<numy;jj+=1)				dik=sqrt( (ii-xc)^2+(jj-yc)^2)*grid				if(dik<=rad)					mat[ii][jj][zloc] = fill				endif		endfor	endfor		return(0)	End//fills cylinder (fill == 1) or erases it (fill == 0)//// xc,yc,zc is the center// grid is the grid spacing (A)// rad is the desired radius// len is the desired length, in the X-directionFunction FillXCylinder(mat,grid,rad,xc,yc,zc,len,fill)	WAVE mat	Variable grid,rad,xc,yc,zc,len,fill		Variable ii,pts	//put half the length above - half below	pts = trunc(len/2/grid)	for(ii=(xc-pts);ii<(xc+pts);ii+=1)		FillYZCircle(mat,grid,rad,yc,zc,ii,fill)	endfor		return(0)	End//fills the specified circle (fill==1), or erases it (fill == 0)//xloc assumed to be a valid x-index of the matrixFunction FillYZCircle(mat,grid,rad,yc,zc,xloc,fill)	WAVE mat	Variable grid,rad,yc,zc,xloc,fill		Variable ii,jj,dik,numx,numy,numz		numy=DimSize(mat,0)	numz=DimSize(mat,1)	for(ii=0;ii<numy;ii+=1)		for(jj=0;jj<numz;jj+=1)				dik=sqrt( (ii-yc)^2+(jj-zc)^2)*grid				if(dik<=rad)					mat[xloc][ii][jj] = fill				endif		endfor	endfor		return(0)	End//fills cylinder (fill == 1) or erases it (fill == 0)//// xc,yc,zc is the center// grid is the grid spacing (A)// rad is the desired radius// len is the desired length, in the Y-directionFunction FillYCylinder(mat,grid,rad,xc,yc,zc,len,fill)	WAVE mat	Variable grid,rad,xc,yc,zc,len,fill		Variable ii,pts	//put half the length above - half below	pts = trunc(len/2/grid)	for(ii=(yc-pts);ii<(yc+pts);ii+=1)		FillXZCircle(mat,grid,rad,xc,zc,ii,fill)	endfor		return(0)	End//fills the specified circle (fill==1), or erases it (fill == 0)//yloc assumed to be a valid y-index of the matrixFunction FillXZCircle(mat,grid,rad,xc,zc,yloc,fill)	WAVE mat	Variable grid,rad,xc,zc,yloc,fill		Variable ii,jj,dik,numx,numy,numz		numx=DimSize(mat,0)	numz=DimSize(mat,1)	for(ii=0;ii<numx;ii+=1)		for(jj=0;jj<numz;jj+=1)				dik=sqrt( (ii-xc)^2+(jj-zc)^2)*grid				if(dik<=rad)					mat[ii][yloc][jj] = fill				endif		endfor	endfor		return(0)	End// uses the Sobol' sequence to fill the points// - likely more "evenly" spread out than a random pick// -- but is it too regular?Function SobolFill3DMat(mat,num,fill)	Wave mat	variable num,fill		//number of spheres to add		Variable row,col,lay,ii,xt,yt,zt,fail=0		Make/O/D/N=3 Sobol3D		// initialize. XOP should prevent re-initialization	SobolX(-1,Sobol3D)	row=DimSize(mat,0)			col=DimSize(mat,1)	lay=DimSize(mat,2)	ii=0	do		SobolX(3,Sobol3D)		xt = trunc(row*Sobol3D[0])		yt = trunc(col*Sobol3D[1])		zt = trunc(lay*Sobol3D[2])		if( NoNeighbors(xt,yt,zt,mat) )			mat[xt][yt][zt] = fill			ii+=1		//increment number of spheres actually added			//Print "point ",ii		else			fail +=1		endif	while(ii<num)//	Print "failures = ",fail	//	ParseMatrix3D_rho(mat)		//convert to XYZ		return(0)EndFunction RandomFill3DMat(mat,num,fill)	Wave mat	variable num,fill		//number of spheres to add		Variable row,col,lay,ii,xt,yt,zt,fail=0		row=DimSize(mat,0)			col=DimSize(mat,1)	lay=DimSize(mat,2)		//place first 2 points	//xt=trunc(abs(enoise(row)))		//random integer distr betw (0,row-1)	//yt=trunc(abs(enoise(col)))	//zt=trunc(abs(enoise(lay)))	//mat[xt][yt][1] = 1	//mat[xt][yt][2] = 1	//loop over remaining spheres to add	ii=0	do		xt=trunc(abs(enoise(row)))		//distr betw (0,npt)		yt=trunc(abs(enoise(col)))		zt=trunc(abs(enoise(lay)))		if( NoNeighbors(xt,yt,zt,mat) )			mat[xt][yt][zt] = fill			ii+=1		//increment number of spheres actually added			//Print "point ",ii		else			fail +=1		endif	while(ii<num)	Print "failures = ",fail	//	ParseMatrix3D_rho(mat)		//convert to XYZ		return(0)End//point is considered valid if (x,y,z) is unoccupied// AND there is a NO neighbor (no connectivity)//// could speed this up by immediately bouncing out when the first neighbor is foundFunction NoNeighbors(xt,yt,zt,mat)	Variable xt,yt,zt	WAVE mat	//returns 1 if valid, 0 if not valid	Variable valid=1,invalid=0,xMax,yMax,zMax,ncont=0		NVAR 	solventSLD = root:FFT_SolventSLD	if(mat[xt][yt][zt] != solventSLD)		//already occupied, trial is invalid		return (invalid)	Endif		xMax=DimSize(mat,0) - 1			//max index of the array	yMax=DimSize(mat,1) - 1		zMax=DimSize(mat,2) - 1		//connected?	//any of the surrounding 26 points occupied?	Variable xi,yi,zi,ii,jj,kk	for(ii=-1;ii<=1;ii+=1)		xi = xt+ii		xi = (xi< 0) ? 0 : xi		//keep in bounds of matrix index		xi = (xi>xMax) ? xMax : xi		for(jj=-1;jj<=1;jj+=1)			yi = yt + jj			yi = (yi<0) ? 0 : yi			yi = (yi>yMax) ? yMax : yi			for(kk=-1;kk<=1;kk+=1)				zi = zt+kk				zi = (zi<0) ? 0 : zi				zi = (zi>zMax) ? zMax : zi				if( (xi==xt) && (yi==yt) && (zi==zt) )					//at central point, do nothing				else					if(mat[xi][yi][zi] != solventSLD)						ncont+=1					endif				endif			endfor		endfor	endfor		//if((ncont > 0) && (ncont <2) )	// only one neighbor	if(ncont==0)			// no nearest neighbor contact points		return(valid)	else		return(invalid)	endifEndProc ParseMatrix3DToXYZ(matStr)	String matStr="mat"	ParseMatrix3D_rho($matStr)End////// Depricated - use ParseMatrix3D_rho() instead, to get the SLD information//////// parses the 3d matrix to get xyz coordinates// CHANGE - ? Make as byte waves to save space//// XYZ waves are hard-wired to be "x3d,y3d,z3d"// overwrites previous waves////Function ParseMatrix3D(mat)//	Wave mat//	//	Variable nptx,npty,nptz,ii,jj,kk,num//	//	nptx=DimSize(mat,0)//	npty=DimSize(mat,1)//	nptz=DimSize(mat,2)	//	Make/O/D/N=0 x3d,y3d,z3d		//ensure that the waves are SP//	num=0//	//	for(ii=0;ii<nptx;ii+=1)//		for(jj=0;jj<npty;jj+=1)//			for(kk=0;kk<nptz;kk+=1)//				if(mat[ii][jj][kk])//					num+=1//					InsertPoints num,1,x3d,y3d,z3d//					x3d[num-1]=ii//					y3d[num-1]=jj//					z3d[num-1]=kk//				endif//			endfor//		endfor//	endfor//	//	return(0)//End// parses the 3d matrix to get xyz coordinates// CHANGE - ? Make as byte waves to save space//// XYZ waves are hard-wired to be "x3d,y3d,z3d"// overwrites previous waves//Function ParseMatrix3D_rho(mat)	Wave mat		Variable nptx,npty,nptz,ii,jj,kk,num		NVAR 	solventSLD = root:FFT_SolventSLD	nptx=DimSize(mat,0)	npty=DimSize(mat,1)	nptz=DimSize(mat,2)		Make/O/D/N=0 x3d,y3d,z3d,rho3d		//ensure that the waves are DP	num=0		for(ii=0;ii<nptx;ii+=1)		for(jj=0;jj<npty;jj+=1)			for(kk=0;kk<nptz;kk+=1)				if(mat[ii][jj][kk]!=solventSLD)					num+=1					InsertPoints num,1,x3d,y3d,z3d,rho3d					x3d[num-1]=ii					y3d[num-1]=jj					z3d[num-1]=kk					rho3d[num-1]=mat[ii][jj][kk]				endif			endfor		endfor	endfor		return(0)EndFunction ConvertXYZto3N(xw,yw,zw)	Wave xw,yw,zw		Variable num=numpnts(xw)	Make/O/D/N=(num,3) matGiz	Concatenate/O {x3d,y3d,z3d},matGiz		//Igor 5+ only//// or //	matGiz[][0] = xw[p]//	matGiz[][1] = yw[p]//	matGiz[][2] = zw[p]		return(0)End////////////////////pad the matrix with zeros to make it bigger, ?maybe avoid errors// of box size// (this does not yet work.....)//Function PadMatrix(mat,num)	Wave mat	Variable num		Variable numold=DimSize(mat,0)	Make/O/B/U/N=(numold+2*num,numold+2*num,numold+2*num) matNew=0	matNew[num,numold+num-1][num,numold+num-1][num,numold+num-1]=mat[p-num][q-num][r-num]end// takes values at XYZ and converts to a 3D byte volume// - each voxel may have different values//// xyz values are to start from 0->// voxel values must be integer, or they will end up byte//Function XYZV_toByteVoxels(xx,yy,zz,val)	Wave xx,yy,zz,val		Variable x1,x2,y1,y2,z1,z2,ii,jj,kk,num,npt		WaveStats/Q xx	x1 = V_max	WaveStats/Q yy	y1 = V_max		WaveStats/Q zz	z1 = V_max		//get the maximum dimension	npt = max(x1,y1)	npt = max(npt,z1)		Make/O/B/U/N=(npt,npt,npt) VoxelMat=0		num=numpnts(xx)		for(ii=0;ii<num;ii+=1)		VoxelMat[xx[ii]][yy[ii]][zz[ii]] = val[ii]	endfor		return(0)End// takes XYZV values such as output from  Ken Rubinson's converter// where xyz may take negative values, and tries to put it into // mat, shifting XYZ as needed//Function XYZV_FillMat(xx,yy,zz,val,erase)	Wave xx,yy,zz,val	Variable erase		Variable x1,x2,y1,y2,z1,z2,ii,jj,kk,num,npt,minp,maxp		WAVE mat = root:mat	NVAR solventSLD = root:FFT_SolventSLD	if(erase)		mat = solventSLD	endif		WaveStats/Q xx	x1 = V_min	WaveStats/Q yy	y1 = V_min		WaveStats/Q zz	z1 = V_min			// find the minimum xyz	minp = min(x1,y1)	minp = min(minp,z1)//	print "minp = ",minp	if(minp < 0)		minp = abs(minp)	else		minp = 0		// if all of the values are positive, don't shift anything	endif			// will the adjusted xyz values fit the mat?	Variable matp = DimSize(mat,0)		// assume all 3 dimensions are the same		WaveStats/Q xx	x1 = V_max	WaveStats/Q yy	y1 = V_max		WaveStats/Q zz	z1 = V_max		// find the minimum xyz	maxp = max(x1,y1)	maxp = max(maxp,z1)//	Print "maxp = ",maxp		if(x1+minp > matp-1)		Print "Mat is not big enough. x1+minp = ",x1+minp		return(0)	Endif	if(y1+minp > matp-1)		Print "Mat is not big enough. y1+minp = ",y1+minp		return(0)	Endif	if(z1+minp > matp-1)		Print "Mat is not big enough. z1+minp = ",z1+minp		return(0)	Endif		num=numpnts(xx)		for(ii=0;ii<num;ii+=1)		mat[xx[ii]+minp][yy[ii]+minp][zz[ii]+minp] = val[ii]	endfor		return(0)End